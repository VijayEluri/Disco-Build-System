#!/bin/bash -e
#
# Simple launcher script for the "disco" command.
#

# make sure that wildcards (* and ?) aren't expanded. If the user passes in "*.h", we want to
# pass "*.h" onto the Java code.
set -f

# Figure out what this script was executed as - 
export SCRIPT_DIR=`dirname $0`

#
# Now we have two cases for setting up the classpath, depending on where the files are installed.
#
#   1) A development installation inside a Eclipse project
#   2) A fully installed disco release.
#

#
# Case 1 for a development installation - all .class and .jar files are in the Eclipse project layout.
#
if [ -e "$SCRIPT_DIR/../../../DiscoMain" ];
then
    WORK="$SCRIPT_DIR/../../../"
    
	export CLASSPATH="$WORK/BuildStore/priv/bin:$WORK/DiscoMain/priv/bin:$WORK/BuildTreeScanner/priv/bin:$WORK/Utilities/priv/bin"
	export CLASSPATH="$WORK/BuildScanners/priv/bin:$CLASSPATH"
	export CLASSPATH="$WORK/DiscoMain/priv/lib/commons-cli-1.2.jar:$WORK/BuildStore/priv/lib/sqlitejdbc-v056.jar:$CLASSPATH"
	export LD_LIBRARY_PATH="$WORK/Utilities/pub"
	
	# set up a fake root directory, with the latest libraries and binaries. The disco Java code dynamically
	# loads these things
	export DISCO_HOME=$SCRIPT_DIR/../fake-home
	mkdir -p $DISCO_HOME/{bin,lib}
	cp $WORK/ComponentFS/pub/bin/cfs $DISCO_HOME/bin
	cp $WORK/ComponentFS/pub/lib/libcfs.so $DISCO_HOME/lib
	cp $WORK/Utilities/pub/libnativeLib.so $DISCO_HOME/lib
	
#
# Case 2 for a fully installed disco release - everything is in a single jar file.
#
elif [ -e "$SCRIPT_DIR/../lib/disco.jar" ];
then
    export DISCO_HOME=$SCRIPT_DIR/..
	export CLASSPATH="$DISCO_HOME/lib/disco.jar"
	export LD_LIBRARY_PATH="$DISCO_HOME/lib"

#
# Else, it's an error
#
else
    echo Unable to locate disco.jar file.
    exit 1
fi

#
# Now, invoke the disco command line tool, with all the command line arguments.
#
java com.arapiki.disco.main.DiscoMain $*

# Note: the return code from java is the return code for our whole script.
