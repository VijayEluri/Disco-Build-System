/*******************************************************************************
 * Copyright (c) 2011 Arapiki Solutions Inc.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    "Peter Smith <psmith@arapiki.com>" - initial API and 
 *        implementation and/or initial documentation
 *******************************************************************************/ 

package com.arapiki.disco.model;

import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;

/**
 * @author "Peter Smith <psmith@arapiki.com>"
 *
 */
public class FileIncludes {

	/*=====================================================================================*
	 * TYPES/FIELDS
	 *=====================================================================================*/

	/**
	 * Our database manager object, used to access the database content. This is provided 
	 * to us when the FileNameSpaces object is first instantiated.
	 */
	private BuildStoreDB db = null;
	
	/**
	 * Various prepared statement for database access.
	 */
	private PreparedStatement 
		insertFileIncludesPrepStmt = null,
		updateFileIncludesPrepStmt = null,
		selectUsageFromFileIncludesPrepStmt = null,
		selectTotalUsageFromFileIncludesPrepStmt = null,
		selectFile1FromFileIncludesPrepStmt = null,
		selectFile2FromFileIncludesPrepStmt = null;

	/*=====================================================================================*
	 * CONSTRUCTORS
	 *=====================================================================================*/

	/**
	 * Create a new FileDependencies object.
	 * @param db The database manager who provides this object with database access.
	 */
	public FileIncludes(BuildStoreDB db) {
		this.db = db;
		
		/* create prepared database statements */
		insertFileIncludesPrepStmt = db.prepareStatement("insert into fileIncludes values (?, ?, 1)");
		updateFileIncludesPrepStmt = db.prepareStatement("update fileIncludes set usage = usage + 1 " +
				"where fileId1 = ? and fileId2 = ?");
		selectUsageFromFileIncludesPrepStmt = db.prepareStatement(
				"select usage from fileIncludes where fileId1 = ? and fileId2 = ?");
		selectTotalUsageFromFileIncludesPrepStmt = db.prepareStatement(
				"select sum(usage) from fileIncludes where fileId2 = ?");
		selectFile1FromFileIncludesPrepStmt = db.prepareStatement(
				"select fileId1 from fileIncludes where fileId2 = ?");
		selectFile2FromFileIncludesPrepStmt = db.prepareStatement(
				"select fileId2 from fileIncludes where fileId1 = ?");
	}

	/*=====================================================================================*
	 * PUBLIC METHODS
	 *=====================================================================================*/

	/**
	 * Record the fact that file1 somehow depends on file2. This could be in several ways:
	 *   - "compiles" - file1 is generated by compiling file2 (such as .o -> .c)
	 *   - "includes" - file1 includes the content of file2 (such as .c -> .h, or .h -> .h).
	 * @param file1
	 * @param file2
	 */
	public void addFileIncludes(int file1, int file2) {
		
		try {
			updateFileIncludesPrepStmt.setInt(1, file1);
			updateFileIncludesPrepStmt.setInt(2, file2);
			int rowCount = db.executePrepUpdate(updateFileIncludesPrepStmt);
		
			if (rowCount == 0) {
				insertFileIncludesPrepStmt.setInt(1, file1);
				insertFileIncludesPrepStmt.setInt(2, file2);
				db.executePrepUpdate(insertFileIncludesPrepStmt);
			}
		} catch (SQLException e) {
			throw new FatalBuildStoreError("Unable to execute SQL statement", e);
		}
	}

	/*-------------------------------------------------------------------------------------*/

	/**
	 * Given a pair of files, where file1 depends on file2 in some way, return the count of
	 * how many times this dependency relationship has been noted.
	 * @param file1
	 * @param file2
	 * @return The number of times the dependency was noted.
	 */
	public int getFileIncludesCount(int file1, int file2) {
	
		Integer results[];
		try {
			selectUsageFromFileIncludesPrepStmt.setInt(1, file1);
			selectUsageFromFileIncludesPrepStmt.setInt(2, file2);
			results = db.executePrepSelectIntegerColumn(selectUsageFromFileIncludesPrepStmt);
		} catch (SQLException e) {
			throw new FatalBuildStoreError("Unable to execute SQL statement", e);
		}

		/* if there's no entry at all, return a 0 usage count */
		if (results.length == 0) {
			return 0;
		}
		
		/* if there's one entry, that's good - just return that number. */
		if (results.length == 1) {
			return results[0];
		}
		
		/* else, problem - too many records */
		throw new FatalBuildStoreError("Too many records in includes table for " + file1 + "/" + file2);
	}

	/*-------------------------------------------------------------------------------------*/

	/**
	 * Return the total number of times that a specific file is included, regardless of how many
	 * different files include it.
	 * @param file The file in which we're interested.
	 * @return The total number of times the file is accessed by one or more other files.
	 */
	public int getTotalFileIncludedCount(int file) {
		ResultSet rs;
		int usageCount = 0;
		try {
			selectTotalUsageFromFileIncludesPrepStmt.setInt(1, file);
			rs = db.executePrepSelectResultSet(selectTotalUsageFromFileIncludesPrepStmt);
			
			/* if there's no entry at all, return a 0 usage count */			
			if (rs.next()) {
				usageCount = rs.getInt(1);				
			}	
			rs.close();
				
		} catch (SQLException e) {
			throw new FatalBuildStoreError("Unable to execute SQL statement", e);
		}
		return usageCount;		
	}

	/*-------------------------------------------------------------------------------------*/

	/**
	 * 
	 * @param file
	 * @return
	 */
	public Integer[] getFilesThatInclude(int file) {
		
		Integer results[];
		try {
			selectFile1FromFileIncludesPrepStmt.setInt(1, file);
			results = db.executePrepSelectIntegerColumn(selectFile1FromFileIncludesPrepStmt);
			
		} catch (SQLException e) {
			throw new FatalBuildStoreError("Unable to execute SQL statement", e);
		}

		return results;
	}

	/*-------------------------------------------------------------------------------------*/

	/**
	 * 
	 * @param file
	 * @return
	 */
	public Integer[] getFilesIncludedBy(int file) {
		
		Integer results[];
		try {
			selectFile2FromFileIncludesPrepStmt.setInt(1, file);
			results = db.executePrepSelectIntegerColumn(selectFile2FromFileIncludesPrepStmt);
			
		} catch (SQLException e) {
			throw new FatalBuildStoreError("Unable to execute SQL statement", e);
		}

		return results;
	}
	
	/*=====================================================================================*/	
}
